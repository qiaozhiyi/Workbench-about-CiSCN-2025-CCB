# RSA_NestingDoll Writeup

## 1. 题目分析
题目涉及两层 RSA 加密：
- **内层模数 $n_1$**：由四个 512 位素数组成。
- **外层模数 $n$**：由四个 1024 位素数组成。
- **关键逻辑**：外层素数 $p$ 的生成满足 $p-1$ 包含内层素数 $p_1$。具体形式为：
  $$p - 1 = p_1 \times (\text{smooth\_part}) \times \text{prime1} \times \text{prime2}$$ 
  其中 `smooth_part` 是由多个 20 位左右的小素数组成的。

## 2. 漏洞点与攻击方法
由于 $p-1$ 包含一个巨大的质因子 $p_1$（它是 $n_1$ 的因子），且其余部分具有高度的平滑性（Small Factor Smoothness），这使得外层 RSA 模数 $n$ 容易受到 **Pollard's p-1 攻击的变种** 威胁。

### 攻击步骤：
1. **构造底数**：令 $b = a^{n_1} \pmod n$。由于 $p_1 | n_1$ 且 $p_1 | (p-1)$，这一步相当于在指数中“消掉”了大质数部分。
2. **分解外层 $n$**：对 $b$ 不断乘入 $2^{20}$ 以内的小素数作为指数。由于 $(p-1)/p_1$ 是平滑的，底数 $b$ 在模 $p$ 下会比在其他模数（如 $q, r, s$）下更快达到 1。
3. **还原内层 $n_1$**：获得 $n$ 的质因子 $f$ 后，通过 $p_1 = \text{GCD}(f-1, n_1)$ 还原出 $n_1$ 的因子。
4. **解密**：集齐 $n_1$ 的四个因子后，计算 $\phi(n_1)$ 并解密内层密文。

## 3. 解密脚本
脚本详见目录下的 `solution.py`。其核心是通过精细化的 GCD 检查频率，确保在 Pollard's p-1 过程中能够分离出 $n$ 的各个因子。

## 4. Flag
`flag{fak3_r5a_0f_euler_ph1_of_RSA_040a2d35}`
