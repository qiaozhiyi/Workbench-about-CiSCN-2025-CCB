# EzFlag Writeup

## 1. 题目概况
题目提供了一个名为 `EzFlag` 的二进制文件。通过初步运行或字符串搜索，可以发现程序要求输入密码，如果正确则会动态生成并输出 flag。

## 2. 静态分析

### 2.1 主函数分析 (`main`)
反汇编 `main` 函数，逻辑如下：
1. **密码验证**：程序首先要求用户输入密码，并将其与硬编码的字符串 `V3ryStr0ngp@ssw0rd` 进行比较。
2. **Flag 生成循环**：
    - 循环执行 32 次。
    - 每次循环调用函数 `f(v11)` 获取一个字符并打印。
    - 在特定的索引（7, 12, 17, 22）打印分隔符 `-`。
    - 变量 `v11` 初始值为 1，每轮更新公式为：`v11 = v11 * 8 + i + 64`。
3. **延迟**：每轮循环都有 `sleep_for(1s)` 的延迟，这说明 flag 是动态打印的。

### 2.2 核心算法函数 (`f`)
函数 `f(a1)` 的逻辑是一个典型的斐波那契数列计算，但带有模运算：
- 初始值：`v4 = 1`, `v5 = 0`。
- 循环 `a1` 次：
    - `v2 = v4`
    - `v4 = (v5 + v4) % 16`
    - `v5 = v2`
- 返回结果：从全局字符串 `K` 中取索引为 `v5` 的字符。

### 2.3 全局变量 `K`
在静态初始化函数中，可以看到字符串 `K` 被初始化为：
`012ab9c3478d56ef`

## 3. 解题思路
由于 `v11` 的增长速度非常快，直接模拟 `f(v11)` 中的循环可能会导致效率问题。然而，观察到 `f(a1)` 实际上是在计算斐波那契数列模 16。
- 斐波那契数列在模 $n$ 下具有周期性（皮萨诺周期）。
- 对于 $n=16$，其周期长度为 24。
- 因此，`f(v11)` 等同于 `f(v11 % 24)`。

## 4. 脚本实现
```python
def fib_mod_16(n):
    if n == 0: return 0
    a, b = 0, 1
    for _ in range(n):
        a, b = b, (a + b) % 16
    return a

K = "012ab9c3478d56ef"

v11 = 1
flag = "flag{"
for i in range(32):
    # 周期为 24
    idx = fib_mod_16(v11 % 24)
    v9 = K[idx]
    flag += v9
    if i in [7, 12, 17, 22]:
        flag += "-"
    v11 = (v11 * 8 + i + 64)

flag += "}"
print(flag)
```

## 5. 最终 Flag
运行脚本后得到最终结果：
`flag{10632674-1d219-09f29-147a2-760632674}`
